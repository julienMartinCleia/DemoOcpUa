/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.11, using .NET Server 3.4.0 template (version 0)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
** </auto-generated>
**
** Copyright (c) 2006-2024 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://yourorganisation.org/DemoOpcUa/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Created: 20.03.2024
**
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using UnifiedAutomation.UaBase;
using System.Diagnostics;

namespace cleia.DemoOpcUa
{
    #region SlotType Class
    /// <summary>
    /// Slot Type
    /// </summary>
    [DataContract(Namespace = cleia.DemoOpcUa.Namespaces.DemoOpcUaXsd)]
    public partial class SlotType : IEncodeable
    {
        #region Constructors
        /// <summary>
        /// Default constructor
        /// </summary>
        public SlotType()
        {
            Initialize();
        }

        [OnDeserializing]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        private void Initialize()
        {
            m_ProductId = (short)0;
            m_ProductName = null;
            m_Location = new Int16Collection();
            m_Rotation = new Int16Collection();
            m_Dimension = new Int16Collection();
        }
        #endregion

        #region Public Properties

        /// <summary>
        /// </summary>
        [DataMember(Name = "ProductId", IsRequired = false, Order = 1)]
        public short ProductId
        {
            get
            {
                return m_ProductId;
            }
            set
            {
                m_ProductId = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "ProductName", IsRequired = false, Order = 2)]
        public string ProductName
        {
            get
            {
                return m_ProductName;
            }
            set
            {
                m_ProductName = value;
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Location", IsRequired = false, Order = 3)]
        public Int16Collection Location
        {
            get
            {
                return m_Location;
            }
            set
            {
                m_Location = value;

                if (value == null)
                {
                    m_Location = new Int16Collection();
                }
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Rotation", IsRequired = false, Order = 4)]
        public Int16Collection Rotation
        {
            get
            {
                return m_Rotation;
            }
            set
            {
                m_Rotation = value;

                if (value == null)
                {
                    m_Rotation = new Int16Collection();
                }
            }
        }

        /// <summary>
        /// </summary>
        [DataMember(Name = "Dimension", IsRequired = false, Order = 5)]
        public Int16Collection Dimension
        {
            get
            {
                return m_Dimension;
            }
            set
            {
                m_Dimension = value;

                if (value == null)
                {
                    m_Dimension = new Int16Collection();
                }
            }
        }

        #endregion

        #region IEncodeable Members
        /// <summary cref="IEncodeable.TypeId" />
        public virtual ExpandedNodeId TypeId
        {
            get { return DataTypeIds.SlotType; }
        }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public virtual ExpandedNodeId BinaryEncodingId
        {
            get { return ObjectIds.SlotType_Encoding_DefaultBinary; }
        }
        /// <summary cref="IEncodeable.XmlEncodingId" />
        public virtual ExpandedNodeId XmlEncodingId
        {
            get { return ObjectIds.SlotType_Encoding_DefaultXml; }
        }

        /// <summary cref="IEncodeable.Encode(IEncoder)" />
        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace(Namespaces.DemoOpcUaXsd);

            encoder.WriteInt16("ProductId", ProductId);
            encoder.WriteString("ProductName", ProductName);
            encoder.WriteInt16Array("Location", Location);
            encoder.WriteInt16Array("Rotation", Rotation);
            encoder.WriteInt16Array("Dimension", Dimension);

            encoder.PopNamespace();
        }

        /// <summary cref="IEncodeable.Decode(IDecoder)" />
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace(Namespaces.DemoOpcUaXsd);
            ProductId = decoder.ReadInt16("ProductId");
            ProductName = decoder.ReadString("ProductName");
            Location = decoder.ReadInt16Array("Location");
            Rotation = decoder.ReadInt16Array("Rotation");
            Dimension = decoder.ReadInt16Array("Dimension");

            decoder.PopNamespace();
        }

        /// <summary cref="EncodeableObject.IsEqual(IEncodeable)" />
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            if (Object.ReferenceEquals(this, encodeable))
            {
                return true;
            }

            SlotType value = encodeable as SlotType;

            if (value == null)
            {
                return false;
            }
            if (!TypeUtils.IsEqual(m_ProductId, value.m_ProductId)) return false;
            if (!TypeUtils.IsEqual(m_ProductName, value.m_ProductName)) return false;
            if (!TypeUtils.IsEqual(m_Location, value.m_Location)) return false;
            if (!TypeUtils.IsEqual(m_Rotation, value.m_Rotation)) return false;
            if (!TypeUtils.IsEqual(m_Dimension, value.m_Dimension)) return false;

            return true;
        }

        /// <summary cref="ICloneable.Clone" />
        public virtual object Clone()
        {
            SlotType clone = (SlotType)this.MemberwiseClone();

            clone.m_ProductId = (short)TypeUtils.Clone(this.m_ProductId);
            clone.m_ProductName = (string)TypeUtils.Clone(this.m_ProductName);
            clone.m_Location = (Int16Collection)TypeUtils.Clone(this.m_Location);
            clone.m_Rotation = (Int16Collection)TypeUtils.Clone(this.m_Rotation);
            clone.m_Dimension = (Int16Collection)TypeUtils.Clone(this.m_Dimension);

            return clone;
        }
        #endregion

        #region Private Fields
        private short m_ProductId;
        private string m_ProductName;
        private Int16Collection m_Location;
        private Int16Collection m_Rotation;
        private Int16Collection m_Dimension;
        #endregion
    }

    #region SlotTypeCollection class
    /// <summary>
    /// A collection of SlotType objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfSlotType", Namespace = cleia.DemoOpcUa.Namespaces.DemoOpcUa, ItemName = "SlotType")]
    public partial class SlotTypeCollection : List<SlotType>, ICloneable
    {
        #region Constructors
        /// <summary>
        /// Initializes the collection with default values.
        /// </summary>
        public SlotTypeCollection() { }

        /// <summary>
        /// Initializes the collection with an initial capacity.
        /// </summary>
        public SlotTypeCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Initializes the collection with another collection.
        /// </summary>
        public SlotTypeCollection(IEnumerable<SlotType> collection) : base(collection) { }
        #endregion

        #region Static Operators
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        public static implicit operator SlotTypeCollection(SlotType[] values)
        {
            if (values != null)
            {
                return new SlotTypeCollection(values);
            }

            return new SlotTypeCollection();
        }

        /// <summary>
        /// Converts a collection to an array.
        /// </summary>
        public static explicit operator SlotType[](SlotTypeCollection values)
        {
            if (values != null)
            {
                return values.ToArray();
            }

            return null;
        }
        #endregion

        #region ICloneable Methods
        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        public object Clone()
        {
            SlotTypeCollection clone = new SlotTypeCollection(this.Count);

            for (int ii = 0; ii < this.Count; ii++)
            {
                clone.Add((SlotType)TypeUtils.Clone(this[ii]));
            }

            return clone;
        }
        #endregion
    }
    #endregion
    #endregion


    #region EncodeableTypes
    /// <summary>
    /// Contains a method for registering all encodeable types of the namespace.
    /// </summary>
    public class EncodeableTypes
    {
        /// <summary>
        /// Register all encodeable types of the namespace at the communication stack.
        /// The Decoder will decode the registered types.
        /// </summary>
        public static void RegisterEncodeableTypes(MessageContext context)
        {
            context.Factory.AddEncodeableType(typeof(cleia.DemoOpcUa.SlotType));
        }
    }
    #endregion
}
